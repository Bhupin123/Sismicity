"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const chalk_1 = require("chalk");
const api_1 = require("../api");
const ts_1 = require("../util/ts");
const logger_1 = require("../util/logger");
const config_1 = require("../config");
const io_1 = require("../util/io");
class Synchronize extends command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Started event handler.
         */
        this.onStarted = async (result) => {
            await (0, io_1.printLine)((0, chalk_1.bold)(` ▸ ${result.connectionId}`));
            await (0, io_1.printInfo)('   [✓] Synchronization - started');
        };
        /**
         * Prune success handler.
         */
        this.onPruneSuccess = (result) => (0, io_1.printLine)((0, chalk_1.green)('   [✓] Synchronization - pruned') + ` (${result.timeElapsed}s)`);
        /**
         * Migration success handler.
         */
        this.onMigrationSuccess = async (result) => {
            const logDb = (0, logger_1.dbLogger)(result.connectionId);
            const [num, list] = result.data;
            const alreadyUpToDate = num && list.length === 0;
            logDb('Up to date: ', alreadyUpToDate);
            if (alreadyUpToDate) {
                await (0, io_1.printLine)((0, chalk_1.green)('   [✓] Migrations - up to date') + ` (${result.timeElapsed}s)`);
                return;
            }
            await (0, io_1.printLine)((0, chalk_1.green)(`   [✓] Migrations - ${list.length} run`) + ` (${result.timeElapsed}s)`);
            // Completed migrations.
            for (const item of list) {
                await (0, io_1.printLine)((0, chalk_1.cyan)(`       - ${item}`));
            }
        };
        /**
         * Migration failure handler.
         */
        this.onMigrationFailed = async (result) => {
            await (0, io_1.printLine)((0, chalk_1.red)(`   [✖] Migrations - failed (${result.timeElapsed}s)`));
        };
        /**
         * Success handler for the whole process - after all completed.
         */
        this.onSuccess = async (result) => {
            await (0, io_1.printLine)((0, chalk_1.green)('   [✓] Synchronization - completed') + ` (${result.timeElapsed}s)\n`);
        };
        /**
         * Failure handler for the whole process - if the process failed.
         */
        this.onFailed = async (result) => {
            await (0, io_1.printLine)((0, chalk_1.red)(`   [✖] Synchronization - failed (${result.timeElapsed}s)\n`));
        };
    }
    /**
     * Check the results for each connection and display them.
     * All the successful / failed attempts are displayed and errors are logged.
     *
     * @param {SyncResult[]} results
     * @returns {Promise<{ totalCount: number, failedCount: number, successfulCount: number }>}
     */
    async processResults(results) {
        const totalCount = results.length;
        const failedAttempts = results.filter(result => !result.success);
        const successfulCount = totalCount - failedAttempts.length;
        const failedCount = totalCount - successfulCount;
        const allComplete = failedCount === 0;
        // If there are errors, display all of them.
        if (!allComplete) {
            await (0, io_1.printLine)(`Synchronization failed for ${failedCount} connection(s):\n`);
            for (const attempt of failedAttempts) {
                await (0, io_1.printLine)((0, chalk_1.bold)(` ▸ ${attempt.connectionId}\n`));
                await (0, io_1.printError)(attempt.error);
                // Send verbose error with stack trace to debug logs.
                (0, logger_1.log)(attempt.error);
                await (0, io_1.printLine)();
            }
        }
        return { totalCount, failedCount, successfulCount };
    }
    /**
     * CLI command execution handler.
     *
     * @returns {Promise<void>}
     */
    async run() {
        const { flags: parsedFlags } = this.parse(Synchronize);
        const isDryRun = parsedFlags['dry-run'];
        try {
            const config = await (0, config_1.loadConfig)(parsedFlags.config);
            const connections = await (0, config_1.resolveConnections)(config, parsedFlags['connection-resolver']);
            const timeStart = process.hrtime();
            if (isDryRun)
                await (0, io_1.printLine)((0, chalk_1.magenta)('\n• DRY RUN STARTED\n'));
            await (0, io_1.printLine)('Synchronizing...\n');
            // Parse sync-files if provided
            const syncFiles = parsedFlags['sync-files']
                ? parsedFlags['sync-files']
                    .split(',')
                    .map(f => f.trim())
                    .filter(f => f.length > 0)
                : undefined;
            const results = await (0, api_1.synchronize)(config, connections, Object.assign(Object.assign({}, parsedFlags), { 'sync-files': syncFiles, onStarted: this.onStarted, onTeardownSuccess: this.onPruneSuccess, onSuccess: this.onSuccess, onFailed: this.onFailed, onMigrationSuccess: this.onMigrationSuccess, onMigrationFailed: this.onMigrationFailed }));
            const { totalCount, failedCount, successfulCount } = await this.processResults(results);
            if (successfulCount > 0) {
                // Display output.
                await (0, io_1.printLine)(`Synchronization complete for ${successfulCount} / ${totalCount} connection(s). ` +
                    `(${(0, ts_1.getElapsedTime)(timeStart)}s)\n`);
            }
            // If all completed successfully, exit gracefully.
            if (failedCount === 0) {
                if (isDryRun)
                    await (0, io_1.printLine)((0, chalk_1.magenta)('• DRY RUN ENDED\n'));
                return process.exit(0);
            }
            throw new Error(`Synchronization failed for ${failedCount} / ${totalCount} connections.`);
        }
        catch (e) {
            // Send verbose error with stack trace to debug logs.
            (0, logger_1.log)(e);
            await (0, io_1.printError)(e.toString());
            if (isDryRun)
                await (0, io_1.printLine)((0, chalk_1.magenta)('\n• DRY RUN ENDED\n'));
            process.exit(-1);
        }
    }
}
Synchronize.description = 'Synchronize all the configured database connections.';
/**
 * Available CLI flags.
 */
Synchronize.flags = {
    force: command_1.flags.boolean({ char: 'f', description: 'Force synchronization.' }),
    'dry-run': command_1.flags.boolean({ description: 'Dry run synchronization.', default: false }),
    'skip-migration': command_1.flags.boolean({ description: 'Skip running migrations.' }),
    'sync-files': command_1.flags.string({
        helpValue: 'FILE_PATH(s)',
        description: 'Comma separated relative file paths to sync. When provided, skips teardown and only syncs specified files.'
    }),
    only: command_1.flags.string({
        helpValue: 'CONNECTION_ID(s)',
        description: 'Filter provided connection(s). Comma separated ids eg: id1,id2'
    }),
    'connection-resolver': command_1.flags.string({
        helpValue: 'PATH',
        description: 'Path to the connection resolver.'
    }),
    config: command_1.flags.string({
        char: 'c',
        description: 'Custom configuration file.'
    })
};
exports.default = Synchronize;
