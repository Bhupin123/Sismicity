"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const chalk_1 = require("chalk");
const api_1 = require("../api");
const logger_1 = require("../util/logger");
const __1 = require("..");
const io_1 = require("../util/io");
class MigrateRollback extends command_1.Command {
    constructor() {
        super(...arguments);
        /**
         * Started event handler.
         */
        this.onStarted = async (result) => {
            await (0, io_1.printLine)((0, chalk_1.bold)(` ▸ ${result.connectionId}`));
            await (0, io_1.printInfo)('   [✓] Rollback - started');
        };
        /**
         * Success handler.
         */
        this.onSuccess = async (result) => {
            const log = (0, logger_1.dbLogger)(result.connectionId);
            const [num, list] = result.data;
            const allRolledBack = num === 0;
            log('Already on the top of migrations: ', allRolledBack);
            await (0, io_1.printInfo)(`   [✓] Rollback - completed (${result.timeElapsed}s)`);
            if (allRolledBack) {
                await (0, io_1.printLine)('   No more migrations to rollback.\n');
                return;
            }
            // List of migrations rolled back.
            for (const item of list) {
                await (0, io_1.printLine)((0, chalk_1.cyan)(`       - ${item}`));
            }
            await (0, io_1.printInfo)(`   Rolled back ${list.length} migrations.\n`);
        };
        /**
         * Failure handler.
         */
        this.onFailed = async (result) => {
            await (0, io_1.printLine)((0, chalk_1.red)(`   [✖] Rollback - failed (${result.timeElapsed}s)\n`));
        };
    }
    /**
     * CLI command execution handler.
     *
     * @returns {Promise<void>}
     */
    async run() {
        const { flags: parsedFlags } = this.parse(MigrateRollback);
        const isDryRun = parsedFlags['dry-run'];
        const config = await (0, __1.loadConfig)(parsedFlags.config);
        const connections = await (0, __1.resolveConnections)(config, parsedFlags['connection-resolver']);
        if (isDryRun)
            await (0, io_1.printLine)((0, chalk_1.magenta)('\n• DRY RUN STARTED\n'));
        const results = await (0, api_1.migrateRollback)(config, connections, Object.assign(Object.assign({}, parsedFlags), { onStarted: this.onStarted, onSuccess: this.onSuccess, onFailed: this.onFailed }));
        const failedCount = results.filter(({ success }) => !success).length;
        if (failedCount === 0) {
            if (isDryRun)
                await (0, io_1.printLine)((0, chalk_1.magenta)('• DRY RUN ENDED\n'));
            return process.exit(0);
        }
        (0, io_1.printError)(`Error: Rollback failed for ${failedCount} connection(s).`);
        if (isDryRun)
            await (0, io_1.printLine)((0, chalk_1.magenta)('\n• DRY RUN ENDED\n'));
        process.exit(-1);
    }
}
MigrateRollback.description = 'Rollback migrations up to the last run batch.';
MigrateRollback.flags = {
    'dry-run': command_1.flags.boolean({ description: 'Dry run rollback.', default: false }),
    only: command_1.flags.string({
        helpValue: 'CONNECTION_ID(s)',
        description: 'Filter provided connection(s). Comma separated ids eg: id1,id2'
    }),
    'connection-resolver': command_1.flags.string({
        helpValue: 'PATH',
        description: 'Path to the connection resolver.'
    }),
    config: command_1.flags.string({
        char: 'c',
        description: 'Custom configuration file.'
    })
};
exports.default = MigrateRollback;
