"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConnectionsFromEnv = exports.getConnectionId = exports.resolveConnectionsUsingResolver = exports.resolveConnections = exports.validate = exports.loadConfig = exports.getSqlBasePath = exports.isCLI = void 0;
const path = require("path");
const yaml = require("yamljs");
const ramda_1 = require("ramda");
const fs = require("./util/fs");
const logger_1 = require("./util/logger");
const types_1 = require("./util/types");
const configInjection_1 = require("./service/configInjection");
const constants_1 = require("./constants");
const CONFIG_FILE_CONVENTION = /^sync-db-\w+\.yml$/;
/**
 * Check if this is being run via the sync-db cli or not.
 *
 * @returns {boolean}
 */
function isCLI() {
    return process.env.SYNC_DB_CLI === 'true';
}
exports.isCLI = isCLI;
/**
 * Get the SQL base path - the 'sql' directory under the `basePath`.
 *
 * TODO: Think of a better way later.
 *
 * @param {Configuration} config
 * @returns {string}
 */
function getSqlBasePath(config) {
    return path.join(config.basePath, 'sql');
}
exports.getSqlBasePath = getSqlBasePath;
/**
 * Load config yaml file.
 *
 * @returns {Promise<Configuration>}
 */
async function loadConfig(configFilename = constants_1.CONFIG_FILENAME) {
    (0, logger_1.log)('Resolving config file.');
    const isAbsolutePath = path.isAbsolute(configFilename);
    const filename = path.parse(configFilename).base;
    const match = filename.match(CONFIG_FILE_CONVENTION) || filename === constants_1.CONFIG_FILENAME;
    if (!match) {
        throw new Error(`The config filename doesn't match the pattern sync-db.yml or sync-db-*.yml`);
    }
    const filepath = isAbsolutePath ? configFilename : path.join(process.cwd(), configFilename);
    const loadedConfig = (await yaml.load(filepath));
    (0, logger_1.log)('Resolved config file.');
    const loaded = (0, ramda_1.mergeDeepRight)(constants_1.DEFAULT_CONFIG, loadedConfig);
    validate(loaded);
    // Resolve the base path relative to the config file location.
    const configFileLocation = path.dirname(filepath);
    const relativeBasePath = path.join(configFileLocation, loaded.basePath);
    const result = Object.assign(Object.assign({}, loaded), { basePath: relativeBasePath, injectedConfig: Object.assign(Object.assign({}, loaded.injectedConfig), { vars: (0, configInjection_1.prepareInjectionConfigVars)(loaded.injectedConfig.vars) }) });
    (0, logger_1.log)('Resolved configuration:\n%O', result);
    return result;
}
exports.loadConfig = loadConfig;
/**
 * Validate the loaded configuration.
 *
 * @param {Configuration} config
 */
function validate(config) {
    const { injectedConfig } = config;
    (0, logger_1.log)('Validating config.');
    // Shouldn't reach under here unless the user has mismatched the value.
    if (!injectedConfig.vars || !(0, types_1.isObject)(injectedConfig.vars)) {
        throw new Error('Invalid configuration value for `injectedConfig.vars`.');
    }
    // TODO: Validate the remaining loaded config.
    // Throw error if validation fails.
    (0, logger_1.log)('Validation passed.');
}
exports.validate = validate;
/**
 * Resolve database connections.
 *
 * @returns {Promise<ConnectionConfig[]>}
 */
async function resolveConnections(config, resolver) {
    (0, logger_1.log)('Resolving database connections.');
    const filename = path.resolve(process.cwd(), constants_1.CONNECTIONS_FILENAME);
    const connectionsFileExists = await fs.exists(filename);
    let connections;
    // Connection resolution process:
    //  1. If connections file exists, use that to resolve connections.
    //  2. If connection resolver is set via flag or configuration, use it.
    //  3. If 1 & 2 are false, try resolving the connections from the environment. If not found fail with error.
    if (connectionsFileExists) {
        connections = await resolveConnectionsFromFile(filename);
    }
    else if (resolver || config.connectionResolver) {
        connections = await resolveConnectionsUsingResolver(resolver || config.connectionResolver, config);
    }
    else {
        (0, logger_1.log)('Connections file not provided. Loading connection details from env.');
        connections = resolveConnectionsFromEnv();
    }
    (0, logger_1.log)('Resolved connections: %O', connections.map(({ id, client, connection }) => ({
        id,
        client,
        connection: {
            host: connection.host,
            database: connection.database
        }
    })));
    return connections;
}
exports.resolveConnections = resolveConnections;
/**
 * Resolve connections using the provided connection resolver.
 *
 * @param {string} resolver
 * @param {Configuration} config
 * @returns {Promise<ConnectionConfig[]>}
 */
async function resolveConnectionsUsingResolver(resolver, config) {
    (0, logger_1.log)('Resolving connection resolver: %s', resolver);
    const resolverPath = resolver ? path.resolve(process.cwd(), resolver) : '';
    const { resolve } = (await Promise.resolve(`${resolverPath}`).then(s => require(s)));
    if (!resolve) {
        throw new Error(`Resolver '${resolver}' does not expose a 'resolve' function.`);
    }
    return resolve(config);
}
exports.resolveConnectionsUsingResolver = resolveConnectionsUsingResolver;
/**
 * Get the connection id from the config.
 *
 * @param {ConnectionConfig} connectionConfig
 * @returns {string}
 */
function getConnectionId(connectionConfig) {
    if (connectionConfig.id) {
        return connectionConfig.id;
    }
    const { host, database } = connectionConfig.connection;
    return host && database ? `${host}/${database}` : '';
}
exports.getConnectionId = getConnectionId;
/**
 * Validate connection keys.
 *
 * @param {string[]} keys
 * @returns {void}
 */
function validateConnections(keys) {
    const missingVars = keys.filter(key => !process.env[key]);
    if (missingVars.length) {
        throw new Error('Following environment variables were not set: ' + missingVars.join(', '));
    }
}
/**
 * Resolve database connections from Env.
 *
 * @returns {ConnectionConfig[]}
 */
function resolveConnectionsFromEnv() {
    (0, logger_1.log)('Resolving connections from the environment variables.');
    validateConnections(constants_1.REQUIRED_ENV_KEYS);
    const connectionConfig = {
        id: process.env.DB_ID,
        client: process.env.DB_CLIENT,
        connection: {
            host: process.env.DB_HOST,
            port: process.env.DB_PORT ? +process.env.DB_PORT : null,
            user: process.env.DB_USERNAME,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME,
            options: {
                encrypt: process.env.DB_ENCRYPTION === 'true'
            }
        }
    };
    return [connectionConfig];
}
exports.resolveConnectionsFromEnv = resolveConnectionsFromEnv;
/**
 * Resolve connections from the file.
 *
 * @param {string} filename
 * @returns {Promise<ConnectionConfig[]>}
 */
async function resolveConnectionsFromFile(filename) {
    (0, logger_1.log)('Resolving connections file: %s', filename);
    const loaded = await fs.read(filename);
    const { connections } = JSON.parse(loaded);
    // TODO: Validate the connections received from file.
    return connections;
}
