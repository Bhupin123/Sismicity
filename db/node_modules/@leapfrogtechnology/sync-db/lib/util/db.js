"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToConnectionReferences = exports.withTransaction = exports.createInstance = exports.getConfig = exports.isKnexInstance = void 0;
const knex_1 = require("knex");
const logger_1 = require("./logger");
const config_1 = require("../config");
/**
 * Returns true if the provided object is a knex connection instance.
 *
 * TODO: Write tests for this supporting both Knex & Knex.Transaction instances.
 *
 * @param {any} obj
 * @returns {boolean}
 */
function isKnexInstance(obj) {
    return !!(obj.prototype && obj.prototype.constructor && obj.prototype.constructor.name === 'knex');
}
exports.isKnexInstance = isKnexInstance;
/**
 * Extracts the connection config params
 * using provided Knex connection instance.
 *
 * @param {Knex} db
 * @returns {Connection}
 */
function getConfig(db) {
    return Object.assign(Object.assign({}, db.client.config.connection), { client: db.client.config.client, id: (0, config_1.getConnectionId)(db.client.config.connection) });
}
exports.getConfig = getConfig;
/**
 * Create a new connection instance (knex) using the connection config.
 * Throws error if the config already holds a Knex's instance.
 *
 * @param {ConnectionConfig} config
 * @returns {Knex}
 */
function createInstance(config) {
    if (isKnexInstance(config.connection)) {
        throw new Error('The provided connection already contains a connection instance.');
    }
    const { host, database, user } = config.connection;
    (0, logger_1.log)(`Connecting to database: ${host}/${database}`);
    if (config.client === 'mssql') {
        return (0, knex_1.knex)({
            client: config.client,
            connection: Object.assign(Object.assign({}, config.connection), { server: host, userName: user })
        });
    }
    return (0, knex_1.knex)({
        client: config.client,
        connection: config.connection
    });
}
exports.createInstance = createInstance;
/**
 * Run a callback function with in a transaction.
 * If `dryRun` is true, transaction will not be committed.
 *
 * @param {ConnectionReference} db
 * @param {(trx: Knex.Transaction) => Promise<T>} callback
 * @param {boolean} dryRun?
 * @returns {Promise<T>}
 */
async function withTransaction(db, callback, dryRun) {
    const dbLog = (0, logger_1.dbLogger)(db.id);
    if (dryRun) {
        dbLog('BEGIN: Dry Run transaction');
        const trx = await db.connection.transaction();
        const res = await callback(trx);
        trx.rollback();
        dbLog('END: Dry Run transaction rolled back successfully');
        return res;
    }
    return db.connection.transaction(async (trx) => {
        dbLog('BEGIN: transaction');
        const result = await callback(trx);
        dbLog('END: transaction');
        return result;
    });
}
exports.withTransaction = withTransaction;
/**
 * Map user provided connection(s) to the connection instances.
 *
 * @param {(DatabaseConnections)} connectionConfig
 * @returns {ConnectionReference[]}
 */
function mapToConnectionReferences(connectionConfig) {
    const list = Array.isArray(connectionConfig) ? connectionConfig : [connectionConfig];
    return list.map(config => {
        if (isKnexInstance(config.connection)) {
            (0, logger_1.log)(`Received connection instance to database: ${config.connection.client.config.connection.database}`);
            return { connection: config.connection, id: (0, config_1.getConnectionId)(config) };
        }
        return { connection: createInstance(config), id: (0, config_1.getConnectionId)(config) };
    });
}
exports.mapToConnectionReferences = mapToConnectionReferences;
