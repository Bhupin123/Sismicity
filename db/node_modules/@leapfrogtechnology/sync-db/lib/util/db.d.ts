import { Knex } from 'knex';
import ConnectionConfig from '../domain/ConnectionConfig';
import ConnectionReference from '../domain/ConnectionReference';
/**
 * Database connections given by the user or the CLI frontend.
 */
export type DatabaseConnections = ConnectionConfig[] | ConnectionConfig;
/**
 * Returns true if the provided object is a knex connection instance.
 *
 * TODO: Write tests for this supporting both Knex & Knex.Transaction instances.
 *
 * @param {any} obj
 * @returns {boolean}
 */
export declare function isKnexInstance(obj: any): obj is Knex;
/**
 * Extracts the connection config params
 * using provided Knex connection instance.
 *
 * @param {Knex} db
 * @returns {Connection}
 */
export declare function getConfig(db: Knex): ConnectionConfig;
/**
 * Create a new connection instance (knex) using the connection config.
 * Throws error if the config already holds a Knex's instance.
 *
 * @param {ConnectionConfig} config
 * @returns {Knex}
 */
export declare function createInstance(config: ConnectionConfig): Knex;
/**
 * Run a callback function with in a transaction.
 * If `dryRun` is true, transaction will not be committed.
 *
 * @param {ConnectionReference} db
 * @param {(trx: Knex.Transaction) => Promise<T>} callback
 * @param {boolean} dryRun?
 * @returns {Promise<T>}
 */
export declare function withTransaction<T>(db: ConnectionReference, callback: (trx: Knex.Transaction) => Promise<T>, dryRun?: boolean): Promise<T>;
/**
 * Map user provided connection(s) to the connection instances.
 *
 * @param {(DatabaseConnections)} connectionConfig
 * @returns {ConnectionReference[]}
 */
export declare function mapToConnectionReferences(connectionConfig: DatabaseConnections): ConnectionReference[];
