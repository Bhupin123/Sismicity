"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copy = exports.remove = exports.write = exports.glob = exports.existsDir = exports.exists = exports.read = exports.mkdtempSync = exports.mkdtemp = exports.readDir = exports.mkdir = void 0;
const fs = require("fs");
const os = require("os");
const path = require("path");
const util_1 = require("util");
exports.mkdir = (0, util_1.promisify)(fs.mkdir);
exports.readDir = (0, util_1.promisify)(fs.readdir);
/**
 * Create a temporary directory and return it's path.
 *
 * @returns {Promise<string>}
 */
function mkdtemp() {
    return (0, util_1.promisify)(fs.mkdtemp)(`${os.tmpdir()}${path.sep}`);
}
exports.mkdtemp = mkdtemp;
/**
 * Create a temporary directory and return it's path. (synchronous)
 *
 * @returns {string}
 */
function mkdtempSync() {
    return fs.mkdtempSync(`${os.tmpdir()}${path.sep}`);
}
exports.mkdtempSync = mkdtempSync;
/**
 * Read file contents.
 *
 * @param {string} filename
 * @returns {Promise<string>}
 */
function read(filename) {
    return new Promise((resolve, reject) => {
        fs.readFile(filename, (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data.toString());
        });
    });
}
exports.read = read;
/**
 * Check if the file exists.
 *
 * @param {string} filename
 * @returns {Promise<boolean>}
 */
function exists(filename) {
    return new Promise(resolve => {
        fs.access(filename, fs.constants.F_OK, err => resolve(!err));
    });
}
exports.exists = exists;
/**
 * Check if the directory exist.
 *
 * @param {string} pathName
 * @returns {boolean}
 */
async function existsDir(pathName) {
    try {
        await (0, exports.readDir)(pathName);
        return true;
    }
    catch (err) {
        return false;
    }
}
exports.existsDir = existsDir;
/**
 * Read all files in a directory.
 *
 * @param {string} pathName
 * @returns {Promise<string[]>}
 */
function glob(pathName) {
    return new Promise((resolve, reject) => {
        fs.readdir(pathName, (err, data) => {
            if (err) {
                return reject(err);
            }
            resolve(data);
        });
    });
}
exports.glob = glob;
/**
 * Write contents to file.
 *
 * @param {string} filepath
 * @param {any} data
 * @returns {Promise<void>}
 */
function write(filepath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filepath, data, err => {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
exports.write = write;
/**
 * Remove the file.
 *
 * @param {string} filepath
 * @returns {Promise<void>}
 */
function remove(filepath) {
    return new Promise((resolve, reject) => {
        fs.unlink(filepath, err => {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
exports.remove = remove;
/**
 * Copy file.
 *
 * @param {string} fromPath
 * @param {string} toPath
 * @returns {Promise<void>}
 */
function copy(fromPath, toPath) {
    return new Promise((resolve, reject) => {
        fs.copyFile(fromPath, toPath, err => {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    });
}
exports.copy = copy;
