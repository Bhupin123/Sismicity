"use strict";
/**
 * Programmatic API
 * ----------------
 * This module defines the Programmatic API of sync-db.
 * The functions exposed here are used by the CLI frontend and
 * are also meant to be the public interface for the developers using it as a package.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateList = exports.migrateRollback = exports.migrateLatest = exports.prune = exports.synchronize = void 0;
const tslib_1 = require("tslib");
const init = require("./init");
const logger_1 = require("./util/logger");
const fs_1 = require("./util/fs");
const db_1 = require("./util/db");
// Service
const execution_1 = require("./service/execution");
const sync_1 = require("./service/sync");
const knexMigrator_1 = require("./migration/service/knexMigrator");
/**
 * Synchronize all the configured database connections.
 *
 * @param {Configuration} config
 * @param {DatabaseConnections} conn
 * @param {SynchronizeParams} [options]
 * @returns {Promise<OperationResult[]>}
 */
async function synchronize(config, conn, options) {
    (0, logger_1.log)('Synchronize');
    const migrationPath = (0, knexMigrator_1.getMigrationPath)(config);
    const dirExist = await (0, fs_1.existsDir)(migrationPath);
    if (!dirExist) {
        (0, logger_1.log)('Migration directory does not exist');
    }
    const params = Object.assign({ force: false, 'skip-migration': !dirExist }, options);
    const { onStarted: _ } = params, invokeParams = tslib_1.__rest(params, ["onStarted"]);
    // TODO: Need to preload the SQL source code under this step.
    const { knexMigrationConfig } = await init.prepare(config, {
        migrationPath,
        loadSqlSources: true,
        loadMigrations: !params['skip-migration']
    });
    const connections = filterConnections((0, db_1.mapToConnectionReferences)(conn), params.only);
    const processes = connections.map(connection => () => (0, db_1.withTransaction)(connection, trx => (0, sync_1.runSynchronize)(trx, {
        config,
        params,
        connectionId: connection.id,
        migrateFunc: t => (0, knexMigrator_1.invokeMigrationApi)(t, knexMigrator_1.KnexMigrationAPI.MIGRATE_LATEST, {
            config,
            connectionId: connection.id,
            knexMigrationConfig: knexMigrationConfig(connection.id),
            params: Object.assign(Object.assign({}, invokeParams), { onSuccess: params.onMigrationSuccess, onFailed: params.onMigrationFailed })
        })
    }), params['dry-run']));
    return (0, execution_1.executeProcesses)(processes, config);
}
exports.synchronize = synchronize;
/**
 * Prune all synchronized objects from the databases (except the ones like tables made via migrations).
 *
 * TODO: An ability to prune only a handful of objects from the last.
 *
 * @param {Configuration} config
 * @param {(DatabaseConnections)} conn
 * @param {OperationParams} [options]
 * @returns {Promise<OperationResult[]>}
 */
async function prune(config, conn, options) {
    (0, logger_1.log)('Prune');
    const params = Object.assign({}, options);
    // TODO: Need to preload the SQL source code under this step.
    await init.prepare(config, { loadSqlSources: true });
    const connections = filterConnections((0, db_1.mapToConnectionReferences)(conn), params.only);
    const processes = connections.map(connection => () => (0, db_1.withTransaction)(connection, trx => (0, sync_1.runPrune)(trx, {
        config,
        params,
        connectionId: connection.id
    }), params['dry-run']));
    return (0, execution_1.executeProcesses)(processes, config);
}
exports.prune = prune;
/**
 * Migrate Latest.
 *
 * @param {Configuration} config
 * @param {(DatabaseConnections)} conn
 * @param {OperationParams} [options]
 * @returns {Promise<OperationResult[]>}
 */
async function migrateLatest(config, conn, options) {
    (0, logger_1.log)('Migrate Latest');
    const params = Object.assign({}, options);
    const { knexMigrationConfig } = await init.prepare(config, {
        loadMigrations: true,
        migrationPath: (0, knexMigrator_1.getMigrationPath)(config)
    });
    const connections = filterConnections((0, db_1.mapToConnectionReferences)(conn), params.only);
    const processes = connections.map(connection => () => (0, db_1.withTransaction)(connection, trx => (0, knexMigrator_1.invokeMigrationApi)(trx, knexMigrator_1.KnexMigrationAPI.MIGRATE_LATEST, {
        config,
        params,
        connectionId: connection.id,
        knexMigrationConfig: knexMigrationConfig(connection.id)
    }), params['dry-run']));
    return (0, execution_1.executeProcesses)(processes, config);
}
exports.migrateLatest = migrateLatest;
/**
 * Migrate Rollback.
 *
 * @param {Configuration} config
 * @param {(DatabaseConnections)} conn
 * @param {OperationParams} [options]
 * @returns {Promise<OperationResult[]>}
 */
async function migrateRollback(config, conn, options) {
    (0, logger_1.log)('Migrate Rollback');
    const params = Object.assign({}, options);
    const { knexMigrationConfig } = await init.prepare(config, {
        loadMigrations: true,
        migrationPath: (0, knexMigrator_1.getMigrationPath)(config)
    });
    const connections = filterConnections((0, db_1.mapToConnectionReferences)(conn), params.only);
    const processes = connections.map(connection => () => (0, db_1.withTransaction)(connection, trx => (0, knexMigrator_1.invokeMigrationApi)(trx, knexMigrator_1.KnexMigrationAPI.MIGRATE_ROLLBACK, {
        config,
        params,
        connectionId: connection.id,
        knexMigrationConfig: knexMigrationConfig(connection.id)
    }), params['dry-run']));
    return (0, execution_1.executeProcesses)(processes, config);
}
exports.migrateRollback = migrateRollback;
/**
 * List Migrations.
 *
 * @param {Configuration} config
 * @param {(DatabaseConnections)} conn
 * @param {OperationParams} [options]
 * @returns {Promise<OperationResult[]>}
 */
async function migrateList(config, conn, options) {
    (0, logger_1.log)('Migrate List');
    const params = Object.assign({}, options);
    const { knexMigrationConfig } = await init.prepare(config, {
        loadMigrations: true,
        migrationPath: (0, knexMigrator_1.getMigrationPath)(config)
    });
    const connections = filterConnections((0, db_1.mapToConnectionReferences)(conn), params.only);
    const processes = connections.map(connection => () => (0, db_1.withTransaction)(connection, trx => (0, knexMigrator_1.invokeMigrationApi)(trx, knexMigrator_1.KnexMigrationAPI.MIGRATE_LIST, {
        config,
        params,
        connectionId: connection.id,
        knexMigrationConfig: knexMigrationConfig(connection.id)
    })));
    return (0, execution_1.executeProcesses)(processes, config);
}
exports.migrateList = migrateList;
/**
 * Check the filter condition and apply filter if required.
 *
 * @param {ConnectionReference[]} connections
 * @param {string} [connectionIds]
 * @returns {ConnectionReference[]}
 */
function filterConnections(connections, connectionIds) {
    const trimmedFilterConnectionIds = Array.from(new Set(connectionIds === null || connectionIds === void 0 ? void 0 : connectionIds.split(',').map(id => id.trim())));
    (0, logger_1.log)(`Filter(s) (--only=) ${trimmedFilterConnectionIds}`);
    // Apply no filter if the connection id is not provided.
    if (!connectionIds) {
        (0, logger_1.log)('Running for all connections.');
        return connections;
    }
    const filteredList = connections.filter(connection => trimmedFilterConnectionIds === null || trimmedFilterConnectionIds === void 0 ? void 0 : trimmedFilterConnectionIds.includes(connection.id));
    const available = connections.map(({ id }) => id);
    const invalidIds = trimmedFilterConnectionIds.filter(tids => !available.includes(tids));
    if (filteredList.length === 0) {
        throw new Error(`No connections found for given id(s) "${trimmedFilterConnectionIds}. Available ids are: ${available}`);
    }
    if (invalidIds.length) {
        (0, logger_1.log)(`No connections found for given id(s) "${invalidIds}. Available ids are: ${available}`);
    }
    const filteredConnectionIds = filteredList.map(({ id }) => id);
    (0, logger_1.log)(`Running for a filtered connection(s) (id(s) = ${filteredConnectionIds}).`);
    return filteredList;
}
