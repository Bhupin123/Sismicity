"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMigrationPath = exports.resolveMigrationContext = exports.invokeMigrationApi = exports.KnexMigrationAPI = void 0;
const path = require("path");
const logger_1 = require("../../util/logger");
const FileExtensions_1 = require("../../enum/FileExtensions");
const execution_1 = require("../../service/execution");
const migrator_1 = require("./migrator");
const SqlMigrationSourceContext_1 = require("../source-types/SqlMigrationSourceContext");
const JavaScriptMigrationSourceContext_1 = require("../source-types/JavaScriptMigrationSourceContext");
var KnexMigrationAPI;
(function (KnexMigrationAPI) {
    KnexMigrationAPI["MIGRATE_LIST"] = "migrate.list";
    KnexMigrationAPI["MIGRATE_LATEST"] = "migrate.latest";
    KnexMigrationAPI["MIGRATE_ROLLBACK"] = "migrate.rollback";
})(KnexMigrationAPI = exports.KnexMigrationAPI || (exports.KnexMigrationAPI = {}));
/**
 * A map of Knex's migration API functions.
 */
const migrationApiMap = {
    // Run up to the latest migrations.
    [KnexMigrationAPI.MIGRATE_LATEST]: (trx, config) => trx.migrate.latest(config),
    // Rollback migrations.
    [KnexMigrationAPI.MIGRATE_ROLLBACK]: (trx, config) => trx.migrate.rollback(config),
    // List migrations.
    [KnexMigrationAPI.MIGRATE_LIST]: (trx, config) => trx.migrate.list(config)
};
/**
 * Invoke Knex's migration API for given function.
 *
 * @param {Knex.Transaction} trx
 * @param {KnexMigrationAPI} funcName
 * @param {MigrationContext} context
 * @returns {Promise<OperationResult>}
 */
async function invokeMigrationApi(trx, funcName, context) {
    return (0, execution_1.executeOperation)(context, async () => {
        const func = migrationApiMap[funcName];
        const dbLog = (0, logger_1.dbLogger)(context.connectionId);
        dbLog(`BEGIN: ${funcName}`);
        const data = await func(trx, context.knexMigrationConfig);
        dbLog(`END: ${funcName}`);
        dbLog('Result:\n%O', data);
        return data;
    });
}
exports.invokeMigrationApi = invokeMigrationApi;
/**
 * Resolve migration context based on the migration configuration.
 *
 * @param {Configuration} config
 * @param {PrepareOptions} options
 * @returns {(Promise<MigrationSourceContext | null>)}
 */
async function resolveMigrationContext(config, options) {
    if (options.loadMigrations !== true || !options.migrationPath) {
        return null;
    }
    (0, logger_1.log)(`Initialize migration context [sourceType=${config.migration.sourceType}]`);
    switch (config.migration.sourceType) {
        case 'sql':
            const src = await (0, migrator_1.resolveSqlMigrations)(options.migrationPath);
            (0, logger_1.log)('Available migration sources:\n%O', src);
            return new SqlMigrationSourceContext_1.default(src);
        case 'javascript':
            const srcJS = await (0, migrator_1.resolveJavaScriptMigrations)(options.migrationPath);
            (0, logger_1.log)('Available migration sources:\n%O', srcJS);
            return new JavaScriptMigrationSourceContext_1.default(srcJS);
        case 'typescript':
            const srcTS = await (0, migrator_1.resolveJavaScriptMigrations)(options.migrationPath, FileExtensions_1.default.TS);
            (0, logger_1.log)('Available migration sources:\n%O', srcTS);
            return new JavaScriptMigrationSourceContext_1.default(srcTS);
        default:
            throw new Error(`Unsupported migration.sourceType value "${config.migration.sourceType}".`);
    }
}
exports.resolveMigrationContext = resolveMigrationContext;
/**
 * Get Migration directory path.
 *
 * @param {Configuration} config
 * @returns {string}
 */
function getMigrationPath(config) {
    const { basePath, migration } = config;
    // Migration directory could be absolute OR could be relative to the basePath.
    const migrationPath = path.isAbsolute(migration.directory)
        ? migration.directory
        : path.join(basePath, migration.directory);
    return migrationPath;
}
exports.getMigrationPath = getMigrationPath;
