"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeJSMigration = exports.makeSqlMigration = exports.makeMigration = exports.publish = void 0;
const path = require("path");
const fs = require("../util/fs");
const logger_1 = require("../util/logger");
const string_1 = require("../util/string");
const ts_1 = require("../util/ts");
const FileExtensions_1 = require("../enum/FileExtensions");
const knexMigrator_1 = require("../migration/service/knexMigrator");
const MIGRATION_TEMPLATE_PATH = path.resolve(__dirname, '../../assets/templates/migration');
const CREATE_TABLE_CONVENTION = /create_(\w+)_table/;
const SOURCE_TYPE_STUBS = {
    sql: ['create_up.stub', 'create_down.stub'],
    javascript: ['create_js.stub', 'update_js.stub'],
    typescript: ['create_ts.stub', 'update_ts.stub']
};
/**
 * Copy stub files to user directory and return list of template names.
 *
 * @param  {Configuration} config
 * @returns {Promise<MakePublishResult>}
 */
async function publish(config) {
    const ignoredList = [];
    const movedList = [];
    const templateBasePath = path.join(config.basePath, '/stub');
    const templateBasePathExists = await fs.exists(templateBasePath);
    const templates = SOURCE_TYPE_STUBS[config.migration.sourceType] || [];
    if (!templateBasePathExists) {
        (0, logger_1.log)(`Template base path does not exist, creating ${templateBasePath}`);
        await fs.mkdir(templateBasePath, { recursive: true });
    }
    (0, logger_1.log)(`Templates to be moved: ${templates}`);
    for (const template of templates) {
        const templatePath = path.join(templateBasePath, template);
        if (await fs.exists(templatePath)) {
            (0, logger_1.log)(`File already exists: ${templatePath}`);
            ignoredList.push(templatePath);
            continue;
        }
        await fs.copy(path.join(MIGRATION_TEMPLATE_PATH, template), path.join(templateBasePath, template));
        movedList.push(templatePath);
    }
    return { ignoredList, movedList };
}
exports.publish = publish;
/**
 * Generate migration file(s).
 *
 * @param {Configuration} config
 * @param {string} filename
 * @param {Partial<MakeOptions} options
 * @returns {Promise<string[]>}
 */
async function makeMigration(config, filename, options) {
    const migrationPath = (0, knexMigrator_1.getMigrationPath)(config);
    const migrationPathExists = await fs.exists(migrationPath);
    if (!migrationPathExists) {
        (0, logger_1.log)(`Migration path does not exist, creating ${migrationPath}`);
        await fs.mkdir(migrationPath, { recursive: true });
    }
    const timestamp = (0, ts_1.getTimestampString)();
    const baseTemplatePath = path.join(config.basePath, '/stub');
    switch (config.migration.sourceType) {
        case 'sql':
            (0, logger_1.log)(`Creating sql migration. ${migrationPath}/${filename}`);
            return makeSqlMigration(filename, Object.assign(Object.assign({}, options), { migrationPath,
                timestamp,
                baseTemplatePath }));
        case 'javascript':
            (0, logger_1.log)(`Creating JS migration. ${migrationPath}/${filename}`);
            return makeJSMigration(filename, Object.assign(Object.assign({}, options), { migrationPath,
                timestamp,
                baseTemplatePath, extension: FileExtensions_1.default.JS }));
        case 'typescript':
            (0, logger_1.log)(`Creating TS migration. ${migrationPath}/${filename}`);
            return makeJSMigration(filename, Object.assign(Object.assign({}, options), { migrationPath,
                timestamp,
                baseTemplatePath, extension: FileExtensions_1.default.TS }));
        default:
            throw new Error(`Unsupported migration.sourceType value "${config.migration.sourceType}".`);
    }
}
exports.makeMigration = makeMigration;
/**
 * Generate sql migration file(s).
 *
 * @param {string} filename
 * @param {MakeOptions} options
 * @returns {Promise<string[]>}
 */
async function makeSqlMigration(filename, options) {
    let createUpTemplate = '';
    let createDownTemplate = '';
    const { migrationPath, timestamp } = options;
    const upFilename = path.join(migrationPath, `${timestamp}_${filename}.up.sql`);
    const downFilename = path.join(migrationPath, `${timestamp}_${filename}.down.sql`);
    // Use the create migration template if the filename follows the pattern: create_<table>_table.sql
    const createTableMatched = filename.match(CREATE_TABLE_CONVENTION);
    const isCreateStub = !!createTableMatched || !!options.create;
    if (isCreateStub) {
        const table = options.objectName || (createTableMatched && createTableMatched[1]);
        (0, logger_1.log)(`Create migration for table: ${table}`);
        createUpTemplate = await getTemplate(options.baseTemplatePath, 'create_up.stub').then(template => (0, string_1.interpolate)(template, { table }));
        createDownTemplate = await getTemplate(options.baseTemplatePath, 'create_down.stub').then(template => (0, string_1.interpolate)(template, { table }));
    }
    await fs.write(upFilename, createUpTemplate);
    await fs.write(downFilename, createDownTemplate);
    return [upFilename, downFilename];
}
exports.makeSqlMigration = makeSqlMigration;
/**
 * Generate JS/TS migration file(s).
 *
 * @param {string} filename
 * @param {MakeOptions} options
 * @returns {Promise<string[]>}
 */
async function makeJSMigration(filename, options) {
    const { migrationPath, timestamp, extension } = options;
    const migrationFilename = path.join(migrationPath, `${timestamp}_${filename}.${extension}`);
    const createTableMatched = filename.match(CREATE_TABLE_CONVENTION);
    const table = options.objectName || (createTableMatched && createTableMatched[1]);
    const isCreateStub = !!createTableMatched || !!options.create;
    (0, logger_1.log)(`Migration for table '${table}' created.`);
    const templateFilename = `${isCreateStub ? 'create' : 'update'}_${extension}.stub`;
    const template = await getTemplate(options.baseTemplatePath, templateFilename);
    await fs.write(migrationFilename, (0, string_1.interpolate)(template, { table }));
    return [migrationFilename];
}
exports.makeJSMigration = makeJSMigration;
/**
 * Get template string by reading stub files either from project base path or sync-db assets' path.
 *
 * @param  {string} baseTemplatePath
 * @param  {string} templateFilename
 * @returns {Promise<string>}
 */
async function getTemplate(baseTemplatePath, templateFilename) {
    const baseFilePathExists = await fs.exists(path.join(baseTemplatePath, templateFilename));
    const templatePath = path.join(baseFilePathExists ? baseTemplatePath : MIGRATION_TEMPLATE_PATH, templateFilename);
    return fs.read(templatePath);
}
