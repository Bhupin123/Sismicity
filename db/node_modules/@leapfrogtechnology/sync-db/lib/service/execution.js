"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeOperation = exports.executeProcesses = void 0;
const ts_1 = require("../util/ts");
const logger_1 = require("../util/logger");
const promise_1 = require("../util/promise");
/**
 * Execute a list of processes according to the configuration.
 *
 * @param {Promiser<T>[]} processes
 * @param {Configuration} config
 * @returns {Promise<T[]>}
 */
function executeProcesses(processes, config) {
    (0, logger_1.log)(`Executing ${processes.length} processes [strategy=${config.execution}]`);
    switch (config.execution) {
        case 'sequential':
            return (0, promise_1.runSequentially)(processes);
        case 'parallel':
            return Promise.all(processes.map(fn => fn()));
        default:
            throw new Error(`Execution strategy should be "sequential" or "parallel" found: "${config.execution}".`);
    }
}
exports.executeProcesses = executeProcesses;
/**
 * Execute a unit operation.
 *
 * @param {T} context
 * @param {(options: any) => Promise<any>} func
 * @returns {Promise<OperationResult>}
 */
async function executeOperation(context, func) {
    const { connectionId } = context;
    const logDb = (0, logger_1.dbLogger)(connectionId);
    const result = { connectionId, success: false, data: null, timeElapsed: 0 };
    const timeStart = process.hrtime();
    // Trigger onStarted handler if bound.
    if (context.params.onStarted) {
        await context.params.onStarted({
            connectionId,
            success: false,
            data: null,
            timeElapsed: (0, ts_1.getElapsedTime)(timeStart)
        });
    }
    try {
        result.data = await func({ timeStart });
        result.success = true;
    }
    catch (e) {
        logDb(`Error caught for connection ${connectionId}:`);
        result.error = e;
    }
    result.timeElapsed = (0, ts_1.getElapsedTime)(timeStart);
    logDb(`Execution completed in ${result.timeElapsed} s`);
    // Invoke corresponding handlers if they're sent.
    if (result.success && context.params.onSuccess) {
        await context.params.onSuccess(result);
    }
    else if (!result.success && context.params.onFailed) {
        await context.params.onFailed(result);
    }
    if (result.error) {
        logDb('Result:\n%O', result);
        throw result;
    }
    return result;
}
exports.executeOperation = executeOperation;
