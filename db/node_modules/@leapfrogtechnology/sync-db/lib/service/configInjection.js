"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanup = exports.setup = exports.convertToKeyValuePairs = exports.prepareInjectionConfigVars = exports.getPackageMetadata = void 0;
const fs = require("fs");
const path = require("path");
const logger_1 = require("../util/logger");
const env_1 = require("../util/env");
const constants_1 = require("../constants");
/**
 * Reads and returns the package.json contents.
 *
 * @returns {*}
 */
function getPackageMetadata() {
    return JSON.parse(fs.readFileSync(path.join(__dirname, '../../package.json')).toString());
}
exports.getPackageMetadata = getPackageMetadata;
/**
 * Gets all the default injected config vars that needs to be
 * always available in the injected config table.
 *
 * @returns {Mapping<string>}
 */
function getDefaultSystemVars() {
    // TODO: Add any default config vars here that should always
    // be available in the __injected_config table.
    return {};
}
/**
 * Prepares config vars for injecting into the target database.
 *
 * @param {Mapping<string>} vars
 * @returns {Mapping<string>}
 */
function prepareInjectionConfigVars(vars) {
    return (0, env_1.expandEnvVarsInMap)(Object.assign(Object.assign({}, vars), getDefaultSystemVars()));
}
exports.prepareInjectionConfigVars = prepareInjectionConfigVars;
/**
 * Convert an object (map of key => value) into an array of key / value pairs.
 *
 * @param {Mapping<string>} vars
 * @returns {KeyValuePair[]}
 */
function convertToKeyValuePairs(vars) {
    return Object.entries(vars).map(([key, value]) => ({ key, value }));
}
exports.convertToKeyValuePairs = convertToKeyValuePairs;
/**
 * Setup the table in the database with the injected config.
 *
 * @param {Knex.Transaction} trx
 * @param {SynchronizeContext} context
 * @returns {Promise<void>}
 */
async function setup(trx, context) {
    const log = (0, logger_1.dbLogger)(context.connectionId);
    const { injectedConfig } = context.config;
    log(`Making sure table ${constants_1.INJECTED_CONFIG_TABLE} doesn't already exists.`);
    const exists = await trx.schema.hasTable(constants_1.INJECTED_CONFIG_TABLE);
    // TODO: Think about a better solution; it shouldn't have existed in the first place.
    if (exists) {
        log('Warning: Table "${INJECTED_CONFIG_TABLE}" already exists. It will be dropped.');
        await cleanup(trx, context);
    }
    const values = convertToKeyValuePairs(injectedConfig.vars);
    if (!values.length) {
        log(`Config not available. Skipping insertion on ${constants_1.INJECTED_CONFIG_TABLE} table.`);
        return;
    }
    // Create table
    log(`Creating table ${constants_1.INJECTED_CONFIG_TABLE}.`);
    await trx.schema.createTable(constants_1.INJECTED_CONFIG_TABLE, table => {
        table.string('key').primary();
        table.string('value');
    });
    // Inject the configurations into the created table.
    log(`Injecting config into ${constants_1.INJECTED_CONFIG_TABLE}.`);
    await trx.insert(values).into(constants_1.INJECTED_CONFIG_TABLE);
    log(`Injected ${values.length} configurations.`);
}
exports.setup = setup;
/**
 * Drop the injected config table.
 *
 * @param {Knex.Transaction} trx
 * @param {SynchronizeContext} context
 * @returns {Promise<void>}
 */
async function cleanup(trx, context) {
    const log = (0, logger_1.dbLogger)(context.connectionId);
    await trx.schema.dropTableIfExists(constants_1.INJECTED_CONFIG_TABLE);
    log(`Cleaned up table ${constants_1.INJECTED_CONFIG_TABLE}.`);
}
exports.cleanup = cleanup;
