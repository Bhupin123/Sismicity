"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollbackSequentially = exports.runSequentially = exports.getDropStatement = exports.extractSqlFileInfo = exports.getFQON = exports.resolveFiles = exports.resolveFile = void 0;
const path = require("path");
const ramda_1 = require("ramda");
const fs = require("../util/fs");
const logger_1 = require("../util/logger");
const promise = require("../util/promise");
const constants_1 = require("../constants");
const DatabaseObjectTypes_1 = require("../enum/DatabaseObjectTypes");
/**
 * SQL DROP statements mapping for different object types.
 */
const dropStatementsMap = {
    [DatabaseObjectTypes_1.default.SCHEMA]: 'DROP SCHEMA IF EXISTS',
    [DatabaseObjectTypes_1.default.VIEW]: 'DROP VIEW IF EXISTS',
    [DatabaseObjectTypes_1.default.FUNCTION]: 'DROP FUNCTION IF EXISTS',
    [DatabaseObjectTypes_1.default.PROCEDURE]: 'DROP PROCEDURE IF EXISTS',
    [DatabaseObjectTypes_1.default.TRIGGER]: 'DROP TRIGGER IF EXISTS'
};
/**
 * Reads an sql file and return it's contents. If a file ends with `.drop` on the config file,
 * dropOnly is set as true, and that object would not be synchronized, only dropped.
 *
 * @param {string} sqlBasePath
 * @param {string} fileName
 * @returns {Promise<SqlCode>}
 */
async function resolveFile(sqlBasePath, fileName) {
    let name = fileName;
    let dropOnly = false;
    if (fileName.includes(constants_1.DROP_ONLY_OBJECT_TERMINATOR)) {
        name = fileName.replace(constants_1.DROP_ONLY_OBJECT_TERMINATOR, '');
        dropOnly = true;
    }
    const filePath = path.resolve(sqlBasePath, name);
    const sql = await fs.read(filePath);
    return { sql, name, dropOnly };
}
exports.resolveFile = resolveFile;
/**
 * Resolves a list of source files.
 *
 * @param {string} sqlBasePath
 * @param {string[]} files
 * @returns {Promise<SqlCode[]>}
 */
async function resolveFiles(sqlBasePath, files) {
    const promises = files.map(filename => resolveFile(sqlBasePath, filename));
    return Promise.all(promises);
}
exports.resolveFiles = resolveFiles;
/**
 * Get fully qualified object name.
 *
 * @param {string} type
 * @param {string} name
 * @param {string} [schema]
 * @returns {string}
 */
function getFQON(type, name, schema) {
    if (type === DatabaseObjectTypes_1.default.SCHEMA || !schema) {
        return name;
    }
    return `${schema}.${name}`;
}
exports.getFQON = getFQON;
/**
 * Extract sql file info from the filePath to rollback the synchronization.
 *
 * @param {string} filePath
 * @returns {SqlFileInfo}
 */
function extractSqlFileInfo(filePath) {
    // filePath can have multiple sub directories e.g. views/dbo/abc/vw_example.sql
    // The first directory is taken as the object type e.g. views
    // The first sub-directory is taken as the schema name (Optional)
    // The last part of the path is taken as the filename.
    const fileParts = filePath.split('/');
    const fileName = fileParts.pop() || '';
    const [type, schema] = fileParts;
    // Remove .sql and .drop (if exists) from the file name.
    const santizeFileNameRegex = /(.sql)|(.drop)/g;
    const name = fileName.replace(santizeFileNameRegex, '');
    const fqon = getFQON(type, name, schema);
    return { name, fqon, type, schema };
}
exports.extractSqlFileInfo = extractSqlFileInfo;
/**
 * Get SQL DROP statement for the provided object type.
 *
 * @param {string} type   Database object type
 * @param {string} fqon   Fully qualified object name.
 * @returns {string}
 */
function getDropStatement(type, fqon) {
    const dropStatement = dropStatementsMap[type];
    if (!dropStatement) {
        const message = `Naming convention must be one of: ${(0, ramda_1.keys)(dropStatementsMap)}.`;
        throw new Error(`No database object type: ${type}. ${message}`);
    }
    return `${dropStatement} ${fqon}`;
}
exports.getDropStatement = getDropStatement;
/**
 * Run raw queries in the transaction sequentially.
 *
 * @param {Knex} trx
 * @param {SqlCode[]} files
 * @param {string} connectionId
 * @returns {Promise<any[]>}
 */
function runSequentially(trx, files, connectionId) {
    const log = (0, logger_1.dbLogger)(connectionId);
    const promises = files.map(file => {
        if (file.dropOnly) {
            log(`Skipping ${file.name} from synchronization.`);
            return () => Promise.resolve();
        }
        log(`Running ${file.name}`);
        return () => trx.raw(file.sql);
    });
    return promise.runSequentially(promises);
}
exports.runSequentially = runSequentially;
/**
 * Rollback SQL files sequentially in reverse order of the file list.
 *
 * @param {Knex} trx
 * @param {SqlFileInfo[]} files
 * @param {string} connectionId
 * @returns {Promise<void>}
 */
async function rollbackSequentially(trx, files, connectionId) {
    const log = (0, logger_1.dbLogger)(connectionId);
    const sqlFiles = files.map(info => ({
        fqon: info.fqon,
        dropStatement: getDropStatement(info.type, info.fqon)
    }));
    for (const sql of (0, ramda_1.reverse)(sqlFiles)) {
        log(`Rolling back: ${sql.fqon}`);
        await trx.raw(sql.dropStatement);
        log('Executed: ', sql.dropStatement);
    }
}
exports.rollbackSequentially = rollbackSequentially;
