"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPrune = exports.runSynchronize = void 0;
const sqlRunner = require("./sqlRunner");
const logger_1 = require("../util/logger");
const config_1 = require("../config");
const ts_1 = require("../util/ts");
const execution_1 = require("./execution");
const configInjection = require("./configInjection");
/**
 * Migrate SQL on a database.
 *
 * @param {Knex.Transaction} trx
 * @param {SynchronizeContext} context
 * @param {boolean} isPartialSync
 * @param {string[]} filesToSync
 * @returns {Promise<void>}
 */
async function setup(trx, context, isPartialSync, filesToSync) {
    const { connectionId } = context;
    const { hooks, sql } = context.config;
    const sqlBasePath = (0, config_1.getSqlBasePath)(context.config);
    const log = (0, logger_1.dbLogger)(connectionId);
    log(`Running setup.`);
    if (isPartialSync && filesToSync.length === 0) {
        log('No SQL files to synchronize using partial sync.');
    }
    // Determine which SQL files to sync
    const sqlFilesToSync = isPartialSync ? filesToSync : sql;
    const sqlScripts = await sqlRunner.resolveFiles(sqlBasePath, sqlFilesToSync);
    const { pre_sync: preMigrationScripts, post_sync: postMigrationScripts } = hooks;
    // Config Injection: Setup
    // This will setup a config table (temporary and accessible only to this transaction).
    await configInjection.setup(trx, context);
    if (preMigrationScripts.length > 0) {
        const preHookScripts = await sqlRunner.resolveFiles(sqlBasePath, preMigrationScripts);
        log('PRE-SYNC: Begin');
        // Run the pre hook scripts
        await sqlRunner.runSequentially(trx, preHookScripts, connectionId);
        log('PRE-SYNC: End');
    }
    // Run the synchronization scripts.
    await sqlRunner.runSequentially(trx, sqlScripts, connectionId);
    if (postMigrationScripts.length > 0) {
        const postHookScripts = await sqlRunner.resolveFiles(sqlBasePath, postMigrationScripts);
        log('POST-SYNC: Begin');
        // Run the pre hook scripts
        await sqlRunner.runSequentially(trx, postHookScripts, connectionId);
        log('POST-SYNC: End');
    }
    // Config Injection: Cleanup
    // Cleans up the injected config and the table.
    await configInjection.cleanup(trx, context);
    log('Finished setup');
}
/**
 * Executes drop statements (if exists) for all the objects
 * that have been created in the database.
 * They're executed in the reverse order of their creation.
 *
 * @param {Knex.Transaction} trx
 * @param {OperationContext} context
 * @returns {Promise<void>}
 */
async function teardown(trx, context) {
    const { sql } = context.config;
    const sqlBasePath = (0, config_1.getSqlBasePath)(context.config);
    const log = (0, logger_1.dbLogger)(context.connectionId);
    log(`Running rollback on connection id: ${context.connectionId}`);
    const fileInfoList = sql.map(filePath => sqlRunner.extractSqlFileInfo(filePath.replace(`${sqlBasePath}/`, '')));
    await sqlRunner.rollbackSequentially(trx, fileInfoList, context.connectionId);
    log('Finished running rollback');
}
/**
 * Run synchronize on the given database connection (transaction).
 *
 * @param {Knex.Transaction} trx
 * @param {SynchronizeContext} context
 * @returns {Promise<OperationResult>}
 */
async function runSynchronize(trx, context) {
    const { connectionId } = context;
    return (0, execution_1.executeOperation)(context, async (options) => {
        const { migrateFunc } = context;
        const { timeStart } = options;
        const log = (0, logger_1.dbLogger)(connectionId);
        // Check if sync-files option is provided
        const syncFiles = context.params['sync-files'];
        const availableSql = context.config.sql;
        // Filter sync files to only include those that are available in the config and exclude any '.drop' files
        const filesToSync = (syncFiles || []).filter(file => availableSql.includes(file) && !file.endsWith('.drop'));
        const isPartialSync = 'sync-files' in context.params && context.params['sync-files'] !== undefined;
        // Skip teardown only if doing partial sync
        if (isPartialSync) {
            log(`Partial sync mode: skipping teardown for ${filesToSync === null || filesToSync === void 0 ? void 0 : filesToSync.length} file(s).`);
        }
        else {
            await teardown(trx, context);
            // Trigger onTeardownSuccess if bound.
            if (context.params.onTeardownSuccess) {
                await context.params.onTeardownSuccess({
                    connectionId,
                    data: null,
                    success: true,
                    timeElapsed: (0, ts_1.getElapsedTime)(timeStart)
                });
            }
        }
        if (context.params['skip-migration']) {
            log('Skipped migrations.');
        }
        else {
            log('Running migrations.');
            await migrateFunc(trx);
        }
        await setup(trx, context, isPartialSync, filesToSync);
    });
}
exports.runSynchronize = runSynchronize;
/**
 * Rune prune operation (drop all synchronized objects) on the given database connection (transaction).
 *
 * @param {Knex.Transaction} trx
 * @param {OperationContext} context
 * @returns {Promise<OperationResult>}
 */
async function runPrune(trx, context) {
    return (0, execution_1.executeOperation)(context, () => teardown(trx, context));
}
exports.runPrune = runPrune;
