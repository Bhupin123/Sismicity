import { Knex } from 'knex';
import SqlCode from '../domain/SqlCode';
import SqlFileInfo from '../domain/SqlFileInfo';
/**
 * Reads an sql file and return it's contents. If a file ends with `.drop` on the config file,
 * dropOnly is set as true, and that object would not be synchronized, only dropped.
 *
 * @param {string} sqlBasePath
 * @param {string} fileName
 * @returns {Promise<SqlCode>}
 */
export declare function resolveFile(sqlBasePath: string, fileName: string): Promise<SqlCode>;
/**
 * Resolves a list of source files.
 *
 * @param {string} sqlBasePath
 * @param {string[]} files
 * @returns {Promise<SqlCode[]>}
 */
export declare function resolveFiles(sqlBasePath: string, files: string[]): Promise<SqlCode[]>;
/**
 * Get fully qualified object name.
 *
 * @param {string} type
 * @param {string} name
 * @param {string} [schema]
 * @returns {string}
 */
export declare function getFQON(type: string, name: string, schema?: string): string;
/**
 * Extract sql file info from the filePath to rollback the synchronization.
 *
 * @param {string} filePath
 * @returns {SqlFileInfo}
 */
export declare function extractSqlFileInfo(filePath: string): SqlFileInfo;
/**
 * Get SQL DROP statement for the provided object type.
 *
 * @param {string} type   Database object type
 * @param {string} fqon   Fully qualified object name.
 * @returns {string}
 */
export declare function getDropStatement(type: string, fqon: string): string;
/**
 * Run raw queries in the transaction sequentially.
 *
 * @param {Knex} trx
 * @param {SqlCode[]} files
 * @param {string} connectionId
 * @returns {Promise<any[]>}
 */
export declare function runSequentially(trx: Knex, files: SqlCode[], connectionId: string): Promise<any[]>;
/**
 * Rollback SQL files sequentially in reverse order of the file list.
 *
 * @param {Knex} trx
 * @param {SqlFileInfo[]} files
 * @param {string} connectionId
 * @returns {Promise<void>}
 */
export declare function rollbackSequentially(trx: Knex, files: SqlFileInfo[], connectionId: string): Promise<void>;
